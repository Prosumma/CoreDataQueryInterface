#!/usr/bin/env ruby

require 'find'
require 'optparse'
require 'ostruct'

$options = OpenStruct::new
$options.force = false
$options.input_path = "."
$options.output_path = nil
$options.merged = false
$options.excluded_entities = []
$options.public = false
$options.suffix = "Attribute"

option_parser = OptionParser::new do |opts|
  opts.on("-f", "--force", "Force overwrite existing files") do |opt|
    $options.force = opt
  end
  opts.on("-i", "--in=PATH", "Where to start searching for the data model (defaults to current directory)") do |opt|
    $options.input_path = opt
  end
  opts.on("-o", "--out=PATH", "Where to put the resulting files (defaults to same directory as data model)") do |opt|
    $options.output_path = opt
  end
  opts.on("-m", "--merged", "Creates a single file using the name of the data model") do |opt|
    $options.merged = opt
  end
  opts.on("-x", "--exclude=ENTITY", "Exclude an entity") do |opt|
    $options.excluded_entities << opt
  end
  opts.on("-p", "--public", "Make generated classes public") do |opt|
    $options.public = opt
  end
  opts.on("-s", "--suffix=SUFFIX", "Suffix to use on generated classes and filenames (defaults to Attribute)") do |opt|
    $options.suffix = opt
  end
end

models = option_parser.parse(ARGV)
if models.length == 0
  abort "ERROR: No data model specified. Quitting."
elsif models.length > 1
  abort "ERROR: Multiple data models specified. Please specify only one data model. Quitting."
end

model = models[0]
model_path = nil

Find::find($options.input_path) do |path|
  if path =~ /#{Regexp.quote(model)}\.xcdatamodeld$/
    $stderr.puts "NOTICE: Using data model at #{path}."
    model_path = path
    break
  end
end

abort "Could not find #{model} data model in #{$options.input_path}. Quitting." if model_path.nil?

require 'rexml/document'
require 'rexml/xpath'

class Attribute
  attr_reader :name, :entity
  def initialize(name, entity: nil)
    @name = name
    @entity = entity
  end
  def render_property(io)
    if @entity
      io.puts "\tprivate var _#{@name}: #{@entity}#{$options.suffix}!"
      io.puts "\tvar #{@name}: #{@entity}#{$options.suffix} {"
      io.puts "\t\tif _#{@name} == nil { _#{@name} = #{@entity}#{$options.suffix}(name: \"#{@name}\", parent: self) }"
      io.puts "\t\treturn _#{@name}"
      io.puts "\t}"
    else
      io.puts "\tlet #{@name}: Attribute"
    end
  end
  def render_init(io)
    io.puts "\t\t#{@name} = Attribute(name: \"#{@name}\", parent: self)" if @entity.nil?
  end
end

class Entity
  attr_reader :name
  def initialize(name)
    @name = name
    @attributes = []
  end
  def <<(attribute)
    @attributes << attribute
  end
  def render(io)
    io.puts "class #{@name}#{$options.suffix}: Attribute {"
    @attributes.each do |attribute|
      attribute.render_property(io)
    end
    io.puts "\trequired init(name: String? = nil, parent: AttributeType? = nil) {"
    io.puts "\t\tsuper.init(name: name, parent: parent)"
    @attributes.each do |attribute|
      attribute.render_init(io)
    end
    io.puts "\t}"
    io.puts "}"
  end
end

entities = []

File::open(File::join(model_path, "#{model}.xcdatamodel/contents")) do |fd|
  xml = REXML::Document::new(fd)  
  xml.root.elements.each('entity') do |entity_node|
    entity_name = entity_node.attributes['name']
    unless $options.excluded_entities.include?(entity_name)
      entity = Entity::new(entity_node.attributes['name'])
      entity_node.elements.each('attribute') do |attribute_node|
        attribute_name = attribute_node.attributes['name']
        entity << Attribute::new(attribute_name)
      end
      entity_node.elements.each('relationship') do |relationship_node|
        destination_entity_name = relationship_node.attributes['destinationEntity']
        unless $options.excluded_entities.include?(destination_entity_name)
          attribute_name = relationship_node.attributes['name']
          entity << Attribute::new(attribute_name, entity: destination_entity_name)
        end
      end
      entities << entity
    end
  end
end

entities.each do |entity|
  entity.render $stdout
end

