#!/usr/bin/env ruby

require 'find'
require 'optparse'
require 'ostruct'

$options = OpenStruct::new
$options.force = false
$options.input_path = "."
$options.output_path = nil
$options.merged = false
$options.excluded_entities = []
$options.access_modifier = ""
$options.suffix = "Attribute"
$options.indent = 4

option_parser = OptionParser::new do |opts|
  opts.on("-f", "--force", "Force overwrite existing files") do |opt|
    $options.force = opt
  end
  opts.on("-i", "--in=PATH", "Where to start searching for the data model (defaults to current directory)") do |opt|
    $options.input_path = opt
  end
  opts.on("-o", "--out=PATH", "Where to put the resulting files (defaults to same directory as data model)") do |opt|
    $options.output_path = opt
  end
  opts.on("-m", "--merged", "Creates a single file using the name of the data model") do |opt|
    $options.merged = opt
  end
  opts.on("-x", "--exclude=ENTITY", "Exclude an entity") do |opt|
    $options.excluded_entities << opt
  end
  opts.on("-p", "--public", "Make generated classes public") do |opt|
    $options.access_modifier = opt ? 'public ' : ''
  end
  opts.on("-s", "--suffix=SUFFIX", "Suffix to use on generated classes and filenames (defaults to Attribute)") do |opt|
    $options.suffix = opt
  end
  opts.on("-n", "--indent=COUNT", OptionParser::DecimalInteger, "Number of spaces to indent (defaults to 2)") do |opt|
    $options.indent = opt
  end
end

models = option_parser.parse(ARGV)
if models.length == 0
  abort "ERROR: No data model specified. Quitting."
elsif models.length > 1
  abort "ERROR: Multiple data models specified. Please specify only one data model. Quitting."
end

model = models[0]
model_path = nil

Find::find($options.input_path) do |path|
  if path =~ /#{Regexp.quote(model)}\.xcdatamodeld$/
    $stderr.puts "NOTICE: Using data model at #{path}."
    model_path = path
    $options.output_path ||= File::dirname(path)
    break
  end
end

abort "Could not find #{model} data model in #{$options.input_path}. Quitting." if model_path.nil?

require 'rexml/document'
require 'rexml/xpath'

class IndentWriter
  def initialize(io)
    @io = io
    @level = 0
  end
  def puts(s)
    @io.puts "#{''.ljust($options.indent * @level, ' ')}#{s}"
  end
  def indent(level = 1)
    @level += level
    yield
    @level -= level
  end
end

class Attribute
  attr_reader :name, :entity
  def initialize(name, entity: nil)
    @name = name
    @entity = entity
  end
  def render_property(io)
    if @entity
      io.puts ""
      io.puts "private var _#{@name}: #{@entity}#{$options.suffix}!"
      io.puts "#{$options.access_modifier}var #{@name}: #{@entity}#{$options.suffix} {"
      io.indent do
        io.puts "if _#{@name} == nil { _#{@name} = #{@entity}#{$options.suffix}(\"#{@name}\", parent: self) }"
        io.puts "return _#{@name}"
      end
      io.puts "}"
    else
      io.puts "#{$options.access_modifier}private(set) var #{@name}: Attribute!"
    end
  end
  def render_init(io)
    io.puts "self.#{@name} = Attribute(\"#{@name}\", parent: self)" if @entity.nil?
  end
end

class Entity
  attr_reader :name
  def initialize(name)
    @name = name
    @attributes = []
  end
  def <<(attribute)
    @attributes << attribute
  end
  def render(io)
    io.puts "#{$options.access_modifier}class #{@name}#{$options.suffix}: Attribute {"
    io.indent do
      @attributes.each do |attribute|
        attribute.render_property(io)
      end
      io.puts ""
      io.puts "#{$options.access_modifier}required init(_ name: String? = nil, parent: AttributeType? = nil) {"
      io.indent do
        io.puts "super.init(name, parent: parent)"
        @attributes.each do |attribute|
          attribute.render_init(io)
        end
      end
      io.puts "}"
    end
    io.puts "}"
  end
end

entities = []

File::open(File::join(model_path, "#{model}.xcdatamodel/contents")) do |fd|
  xml = REXML::Document::new(fd)  
  xml.root.elements.each('entity') do |entity_node|
    entity_name = entity_node.attributes['name']
    unless $options.excluded_entities.include?(entity_name)
      entity = Entity::new(entity_node.attributes['name'])
      entity_node.elements.each('attribute') do |attribute_node|
        attribute_name = attribute_node.attributes['name']
        entity << Attribute::new(attribute_name)
      end
      entity_node.elements.each('relationship') do |relationship_node|
        destination_entity_name = relationship_node.attributes['destinationEntity']
        unless $options.excluded_entities.include?(destination_entity_name)
          attribute_name = relationship_node.attributes['name']
          entity << Attribute::new(attribute_name, entity: destination_entity_name)
        end
      end
      entities << entity
    end
  end
end

if $options.merged
  output_file = File.join($options.output_path, "#{model}#{$options.suffix}.swift")
  if $options.force || !File.exists?(output_file)
    File::open(output_file, 'w') do |io|
      iw = IndentWriter::new(io)
      entities.each do |entity|
        entity.render iw
      end
    end
    $stderr.puts "NOTICE: Wrote file #{output_file}."
  else
    abort "ERROR: The file '#{output_file}' exists and --force was not specified. Quitting."
  end
else
  entities.each do |entity|
    output_file = File.join($options.output_path, "#{entity.name}#{$options.suffix}.swift")
    if $options.force || !File.exists?(output_file)
      File::open(output_file, 'w') do |io|
        entity.render IndentWriter::new(io) 
      end
      $stderr.puts "NOTICE: Wrote file #{output_file}."
    else
      $stderr.puts "WARNING: The file '#{output_file}' exists and --force was not specified. Skipping."
    end
  end
end

